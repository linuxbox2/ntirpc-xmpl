/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "fchan.h"
#include "bchan.h"

#define FREE_FCHAN_MSG_NONE     0x0000
#define FREE_FCHAN_MSG_FREESELF 0x0001

static void
free_fchan_msg(fchan_msg *msg, unsigned int flags)
{
    if (!msg)
        return;
    free(msg->msg1);
    free(msg->msg2);
    if (flags & FREE_FCHAN_MSG_FREESELF)
        free(msg);
    return;
}

void
thread_delay_s(int s)
{
    time_t now;
    struct timespec then;
    pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t cv = PTHREAD_COND_INITIALIZER;

    now = time(0);
    then.tv_sec = now + 5;
    then.tv_nsec = 0;
    
    pthread_mutex_lock(&mtx);
    pthread_cond_timedwait(&cv, &mtx, &then);
    pthread_mutex_unlock(&mtx);
}

extern void bchan_prog_1(struct svc_req *, register SVCXPRT *);

void
cowabunga_rpc_server(CLIENT *cl)
{
    SVCXPRT *xprt;

    printf("Starting RPC service\n");

    /* get a transport handle from our connected client
     * handle, cl is disposed for us */
    xprt = svc_vc_create_cl(cl, 0, 0, SVC_VC_CREATE_CL_FLAG_DEDICATED);
    if (!xprt) {
	fprintf(stderr, "%s\n", "Create SVCXPRT from CLIENT failed");
    }

    /* register service */
    if (!svc_register(xprt, BCHAN_PROG, BCHANV, bchan_prog_1, IPPROTO_TCP)) {
	fprintf (stderr, "%s", "unable to register (BCHAN_PROG, BCHANV, tcp).");
	exit(1);
    }

    /* service the backchannel */
    svc_run ();

    return;
}

static void*
fchan_call_loop(void *arg)
{
    CLIENT *cl = (CLIENT *) arg;
    fchan_res result_1;
    fchan_msg sendmsg1_1_arg;
    enum clnt_stat retval_1;

    sendmsg1_1_arg.seqnum = 0;

    while (1) {

	sendmsg1_1_arg.seqnum++;
	sendmsg1_1_arg.msg1 = strdup("hello");
	sendmsg1_1_arg.msg2 = strdup("it's me again");
	
	/* XDR's encode and decode routines will only
	 * allocate memory if the relevant destination pointer
	 * is NULL */
	memset(&result_1, 0, sizeof(fchan_res));
    
	retval_1 = sendmsg1_1(&sendmsg1_1_arg, &result_1, cl);
	if (retval_1 != RPC_SUCCESS) {
	    clnt_perror (cl, "call failed");
	}

	printf("result: msg1: %s msg2: %s\n", result_1.msg1);

	free_fchan_msg(&sendmsg1_1_arg, FREE_FCHAN_MSG_NONE);

	/* delay 2s (wont appear to be lockstep) */
	thread_delay_s(2);
    }

    clnt_destroy (cl);
}


int
main (int argc, char *argv[])
{
    char *host;
    CLIENT *cl, *cl_backchan;
    enum clnt_stat retval_1;
    pthread_t tid;
    int r;
    
    if (argc < 2) {
        printf ("usage: %s server_host\n", argv[0]);
        exit (1);
    }
    host = argv[1];

    cl = clnt_create (host, FCHAN_PROG, FCHANV, "tcp");
    if (cl == NULL) {
        clnt_pcreateerror (host);
        exit (1);
    }

    /* start forward call loop using cl */
    r = pthread_create(&tid, NULL, &fchan_call_loop, (void*) cl);

    /* create a dedicated connection for the backchan */
    cl_backchan = clnt_create (host, FCHAN_PROG, FCHANV, "tcp");
    if (cl_backchan == NULL) {
        clnt_pcreateerror (host);
        exit (1);
    }

    /* call BIND_CONN_TO_SESSION equivalent RPC */
    retval_1 = bind_conn_to_session1_1(NULL, &r, cl_backchan);
    if (retval_1 != RPC_SUCCESS) {
        clnt_perror (cl_backchan, "call failed2");
    }

    /* switch client to server endpoint and never return */
    cowabunga_rpc_server(cl_backchan);

    exit (0);
}
